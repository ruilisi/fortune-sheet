import _ from "lodash";
import { defaultContext, getFlowdata } from "./context";
import { getRealCellValue, normalizedAttr } from "./modules/cell";
import {
  clearMeasureTextCache,
  defaultFont,
  getCellTextInfo,
  getFontSet,
  getMeasureText,
} from "./modules/text";
import { isInlineStringCell } from "./modules/inline-string";
import { getSheetIndex, indexToColumnChar } from "./utils";
import { getBorderInfoComputeRange } from "./modules/border";
import { checkCF, getComputeMap, validateCellData } from "./modules";

export const defaultStyle = {
  fillStyle: "#000000",
  textBaseline: "middle",
  strokeStyle: "#dfdfdf",
  rowFillStyle: "#5e5e5e",
  textAlign: "center",
};

// 是否是纯数字
function isRealNum(val: any) {
  return !Number.isNaN(Number(val));
}

let cfIconsImg: HTMLImageElement;
function getCfIconsImg() {
  if (cfIconsImg) return cfIconsImg;
  cfIconsImg = new Image();
  cfIconsImg.src =
    "data:image/png;base64,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";
  return cfIconsImg;
}

function getBorderFix(d: any, r: any, c: any) {
  if (_.isEmpty(d[r][c]?.bg)) {
    return [-1, 0, 0, -1];
  }
  return [-2, -1, 1, 0];
}

function setLineDash(
  canvasborder: CanvasRenderingContext2D,
  type: any,
  hv: string,
  moveX: number,
  moveY: number,
  toX: number,
  toY: number
) {
  const borderType: any = {
    "0": "none",
    "1": "Thin",
    "2": "Hair",
    "3": "Dotted",
    "4": "Dashed",
    "5": "DashDot",
    "6": "DashDotDot",
    "7": "Double",
    "8": "Medium",
    "9": "MediumDashed",
    "10": "MediumDashDot",
    "11": "MediumDashDotDot",
    "12": "SlantedDashDot",
    "13": "Thick",
  };

  type = borderType[type.toString()];

  try {
    if (type === "Hair") {
      canvasborder.setLineDash([1, 2]);
    } else if (type.indexOf("DashDotDot") > -1) {
      canvasborder.setLineDash([2, 2, 5, 2, 2]);
    } else if (type.indexOf("DashDot") > -1) {
      canvasborder.setLineDash([2, 5, 2]);
    } else if (type.indexOf("Dotted") > -1) {
      canvasborder.setLineDash([2]);
    } else if (type.indexOf("Dashed") > -1) {
      canvasborder.setLineDash([3]);
    } else {
      canvasborder.setLineDash([0]);
    }
  } catch (e) {
    console.error(e);
  }

  canvasborder.beginPath();

  if (type.indexOf("Medium") > -1) {
    if (hv === "h") {
      canvasborder.moveTo(moveX, moveY - 0.5);
      canvasborder.lineTo(toX, toY - 0.5);
    } else {
      canvasborder.moveTo(moveX - 0.5, moveY);
      canvasborder.lineTo(toX - 0.5, toY);
    }

    canvasborder.lineWidth = 2;
  } else if (type === "Thick") {
    canvasborder.moveTo(moveX, moveY);
    canvasborder.lineTo(toX, toY);
    canvasborder.lineWidth = 3;
  } else {
    canvasborder.moveTo(moveX, moveY);
    canvasborder.lineTo(toX, toY);
    canvasborder.lineWidth = 1;
  }
}

export class Canvas {
  canvasElement: HTMLCanvasElement;

  sheetCtx: ReturnType<typeof defaultContext>;

  measureTextCacheTimeOut: any;

  cellOverflowMapCache: any;

  constructor(
    canvasElement: HTMLCanvasElement,
    ctx: ReturnType<typeof defaultContext>
  ) {
    this.canvasElement = canvasElement;
    this.sheetCtx = ctx;
    this.cellOverflowMapCache = {};
  }

  drawRowHeader(scrollHeight: number, drawHeight?: number, offsetTop?: number) {
    if (_.isNil(drawHeight)) {
      [, drawHeight] = this.sheetCtx.luckysheetTableContentHW;
    }

    if (_.isNil(offsetTop)) {
      offsetTop = this.sheetCtx.columnHeaderHeight;
    }

    const renderCtx = this.canvasElement.getContext("2d");
    if (!renderCtx) return;

    renderCtx.save();
    renderCtx.scale(
      this.sheetCtx.devicePixelRatio,
      this.sheetCtx.devicePixelRatio
    );

    renderCtx.clearRect(
      0,
      offsetTop,
      this.sheetCtx.rowHeaderWidth - 1,
      drawHeight
    );

    renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
    // @ts-ignore
    renderCtx.textBaseline = defaultStyle.textBaseline; // 基准线 垂直居中
    renderCtx.fillStyle = defaultStyle.fillStyle;

    let dataset_row_st;
    let dataset_row_ed;
    dataset_row_st = _.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight);
    dataset_row_ed = _.sortedIndex(
      this.sheetCtx.visibledatarow,
      scrollHeight + drawHeight
    );

    if (dataset_row_st === -1) {
      dataset_row_st = 0;
    }
    if (dataset_row_ed === -1) {
      dataset_row_ed = this.sheetCtx.visibledatarow.length - 1;
    }

    renderCtx.save();
    renderCtx.beginPath();
    renderCtx.rect(
      0,
      offsetTop - 1,
      this.sheetCtx.rowHeaderWidth - 1,
      drawHeight - 2
    );
    renderCtx.clip();

    let end_r;
    let start_r;
    const bodrder05 = 0.5; // Default 0.5
    let preEndR;
    for (let r = dataset_row_st; r <= dataset_row_ed; r += 1) {
      if (r === 0) {
        start_r = -scrollHeight - 1;
      } else {
        start_r = this.sheetCtx.visibledatarow[r - 1] - scrollHeight - 1;
      }
      end_r = this.sheetCtx.visibledatarow[r] - scrollHeight;

      const firstOffset = dataset_row_st === r ? -2 : 0;
      const lastOffset = dataset_row_ed === r ? -2 : 0;
      // 行标题单元格渲染前触发，return false 则不渲染该单元格
      if (
        this.sheetCtx.hooks.beforeRenderRowHeaderCell?.(
          `${r + 1}`,
          r,
          start_r + offsetTop + firstOffset,
          this.sheetCtx.rowHeaderWidth - 1,
          end_r - start_r + 1 + lastOffset - firstOffset,
          renderCtx
        ) === false
      ) {
        continue;
      }

      if (this.sheetCtx.config?.rowhidden?.[r] == null) {
        renderCtx.fillStyle = "#ffffff";
        renderCtx.fillRect(
          0,
          start_r + offsetTop + firstOffset,
          this.sheetCtx.rowHeaderWidth - 1,
          end_r - start_r + 1 + lastOffset - firstOffset
        );
        renderCtx.fillStyle = "#000000";

        // 行标题栏序列号
        renderCtx.save(); // save scale before draw text
        renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
        const textMetrics = getMeasureText(r + 1, renderCtx, this.sheetCtx);

        const horizonAlignPos =
          (this.sheetCtx.rowHeaderWidth - textMetrics.width) / 2;
        const verticalAlignPos = start_r + (end_r - start_r) / 2 + offsetTop;

        renderCtx.fillText(
          `${r + 1}`,
          horizonAlignPos / this.sheetCtx.zoomRatio,
          verticalAlignPos / this.sheetCtx.zoomRatio
        );
        renderCtx.restore(); // restore scale after draw text
      }

      // vertical
      renderCtx.beginPath();
      renderCtx.moveTo(
        this.sheetCtx.rowHeaderWidth - 2 + bodrder05,
        start_r + offsetTop - 2
      );
      renderCtx.lineTo(
        this.sheetCtx.rowHeaderWidth - 2 + bodrder05,
        end_r + offsetTop - 2
      );
      renderCtx.lineWidth = 1;

      renderCtx.strokeStyle = defaultStyle.strokeStyle;
      renderCtx.stroke();
      renderCtx.closePath();

      // 行标题栏横线,horizen
      if (
        this.sheetCtx.config.rowhidden &&
        this.sheetCtx.config.rowhidden[r] == null &&
        this.sheetCtx.config.rowhidden[r + 1] != null
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(-1, end_r + offsetTop - 4 + bodrder05);
        renderCtx.lineTo(
          this.sheetCtx.rowHeaderWidth - 1,
          end_r + offsetTop - 4 + bodrder05
        );
        renderCtx.closePath();
        renderCtx.stroke();
      } else if (
        this.sheetCtx.config.rowhidden == null ||
        this.sheetCtx.config.rowhidden[r] == null
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(-1, end_r + offsetTop - 2 + bodrder05);
        renderCtx.lineTo(
          this.sheetCtx.rowHeaderWidth - 1,
          end_r + offsetTop - 2 + bodrder05
        );

        renderCtx.closePath();
        renderCtx.stroke();
      }

      if (
        this.sheetCtx.config?.rowhidden?.[r - 1] != null &&
        preEndR !== undefined
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(-1, preEndR + offsetTop + bodrder05);
        renderCtx.lineTo(
          this.sheetCtx.rowHeaderWidth - 1,
          preEndR + offsetTop + bodrder05
        );
        renderCtx.closePath();
        renderCtx.stroke();
      }

      preEndR = end_r;

      this.sheetCtx.hooks.afterRenderRowHeaderCell?.(
        `${r + 1}`,
        r,
        start_r + offsetTop + firstOffset,
        this.sheetCtx.rowHeaderWidth - 1,
        end_r - start_r + 1 + lastOffset - firstOffset,
        renderCtx
      );
    }

    // Must be restored twice, otherwise it will be enlarged under window.devicePixelRatio = 1.5
    renderCtx.restore();
    renderCtx.restore();
  }

  drawColumnHeader(
    scrollWidth: number,
    drawWidth?: number,
    offsetLeft?: number
  ) {
    if (drawWidth === undefined) {
      [drawWidth] = this.sheetCtx.luckysheetTableContentHW;
    }

    if (offsetLeft === undefined) {
      offsetLeft = this.sheetCtx.rowHeaderWidth;
    }

    const renderCtx = this.canvasElement.getContext("2d");
    if (!renderCtx) return;

    renderCtx.save();
    renderCtx.scale(
      this.sheetCtx.devicePixelRatio,
      this.sheetCtx.devicePixelRatio
    );
    renderCtx.clearRect(
      offsetLeft,
      0,
      drawWidth,
      this.sheetCtx.columnHeaderHeight - 1
    );

    renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
    // @ts-ignore
    renderCtx.textBaseline = defaultStyle.textBaseline; // 基准线 垂直居中
    renderCtx.fillStyle = defaultStyle.fillStyle;

    let dataset_col_st;
    let dataset_col_ed;
    dataset_col_st = _.sortedIndex(
      this.sheetCtx.visibledatacolumn,
      scrollWidth
    );
    dataset_col_ed = _.sortedIndex(
      this.sheetCtx.visibledatacolumn,
      scrollWidth + drawWidth
    );

    if (dataset_col_st === -1) {
      dataset_col_st = 0;
    }
    if (dataset_col_ed === -1) {
      dataset_col_ed = this.sheetCtx.visibledatacolumn.length - 1;
    }

    renderCtx.save();
    renderCtx.beginPath();
    renderCtx.rect(
      offsetLeft - 1,
      0,
      drawWidth,
      this.sheetCtx.columnHeaderHeight - 1
    );
    renderCtx.clip();

    let end_c;
    let start_c;
    const bodrder05 = 0.5; // Default 0.5
    let preEndC;
    for (let c = dataset_col_st; c <= dataset_col_ed; c += 1) {
      if (c === 0) {
        start_c = -scrollWidth;
      } else {
        start_c = this.sheetCtx.visibledatacolumn[c - 1] - scrollWidth;
      }
      end_c = this.sheetCtx.visibledatacolumn[c] - scrollWidth;

      const abc = indexToColumnChar(c);
      // 列标题单元格渲染前触发，return false 则不渲染该单元格
      if (
        this.sheetCtx.hooks.beforeRenderColumnHeaderCell?.(
          abc,
          c,
          start_c + offsetLeft - 1,
          end_c - start_c,
          this.sheetCtx.columnHeaderHeight - 1,
          renderCtx
        ) === false
      ) {
        continue;
      }

      if (this.sheetCtx.config?.colhidden?.[c] == null) {
        renderCtx.fillStyle = "#ffffff";
        renderCtx.fillRect(
          start_c + offsetLeft - 1,
          0,
          end_c - start_c,
          this.sheetCtx.columnHeaderHeight - 1
        );
        renderCtx.fillStyle = "#000000";

        // 列标题栏序列号
        renderCtx.save(); // save scale before draw text
        renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);

        const textMetrics = getMeasureText(abc, renderCtx, this.sheetCtx);

        const horizonAlignPos = Math.round(
          start_c + (end_c - start_c) / 2 + offsetLeft - textMetrics.width / 2
        );
        const verticalAlignPos = Math.round(
          this.sheetCtx.columnHeaderHeight / 2
        );

        renderCtx.fillText(
          abc,
          horizonAlignPos / this.sheetCtx.zoomRatio,
          verticalAlignPos / this.sheetCtx.zoomRatio
        );
        renderCtx.restore(); // restore scale after draw text
      }

      // 列标题栏竖线 vertical
      if (
        this.sheetCtx.config.colhidden &&
        this.sheetCtx.config.colhidden[c] != null &&
        this.sheetCtx.config.colhidden[c + 1] != null
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(end_c + offsetLeft - 4 + bodrder05, 0);
        renderCtx.lineTo(
          end_c + offsetLeft - 4 + bodrder05,
          this.sheetCtx.columnHeaderHeight - 2
        );
        renderCtx.lineWidth = 1;
        renderCtx.strokeStyle = defaultStyle.strokeStyle;
        renderCtx.closePath();
        renderCtx.stroke();
      } else if (
        this.sheetCtx.config.colhidden == null ||
        this.sheetCtx.config.colhidden[c] == null
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(end_c + offsetLeft - 2 + bodrder05, 0);
        renderCtx.lineTo(
          end_c + offsetLeft - 2 + bodrder05,
          this.sheetCtx.columnHeaderHeight - 2
        );

        renderCtx.lineWidth = 1;
        renderCtx.strokeStyle = defaultStyle.strokeStyle;
        renderCtx.closePath();
        renderCtx.stroke();
      }

      if (
        this.sheetCtx.config?.colhidden?.[c - 1] != null &&
        preEndC !== undefined
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(preEndC + offsetLeft + bodrder05, 0);
        renderCtx.lineTo(
          preEndC + offsetLeft + bodrder05,
          this.sheetCtx.columnHeaderHeight - 2
        );
        renderCtx.closePath();
        renderCtx.stroke();
      }

      // horizen
      renderCtx.beginPath();
      renderCtx.moveTo(
        start_c + offsetLeft - 1,
        this.sheetCtx.columnHeaderHeight - 2 + bodrder05
      );
      renderCtx.lineTo(
        end_c + offsetLeft - 1,
        this.sheetCtx.columnHeaderHeight - 2 + bodrder05
      );
      renderCtx.stroke();
      renderCtx.closePath();

      preEndC = end_c;

      this.sheetCtx.hooks.afterRenderColumnHeaderCell?.(
        abc,
        c,
        start_c + offsetLeft - 1,
        end_c - start_c,
        this.sheetCtx.columnHeaderHeight - 1,
        renderCtx
      );
    }

    // Must be restored twice, otherwise it will be enlarged under window.devicePixelRatio = 1.5
    renderCtx.restore();
    renderCtx.restore();
  }

  drawMain({
    scrollWidth,
    scrollHeight,
    drawWidth,
    drawHeight,
    offsetLeft,
    offsetTop,
    columnOffsetCell,
    rowOffsetCell,
    clear,
  }: {
    scrollWidth: number;
    scrollHeight: number;
    drawWidth?: number;
    drawHeight?: number;
    offsetLeft?: number;
    offsetTop?: number;
    columnOffsetCell?: number;
    rowOffsetCell?: number;
    clear?: boolean;
  }) {
    const flowdata = getFlowdata(this.sheetCtx);
    if (_.isNil(flowdata)) {
      return;
    }

    clearTimeout(this.measureTextCacheTimeOut);

    // 参数未定义处理
    if (drawWidth === undefined) {
      [drawWidth] = this.sheetCtx.luckysheetTableContentHW;
    }
    if (drawHeight === undefined) {
      [, drawHeight] = this.sheetCtx.luckysheetTableContentHW;
    }

    if (offsetLeft === undefined) {
      offsetLeft = this.sheetCtx.rowHeaderWidth;
    }
    if (offsetTop === undefined) {
      offsetTop = this.sheetCtx.columnHeaderHeight;
    }

    if (columnOffsetCell === undefined) {
      columnOffsetCell = 0;
    }
    if (rowOffsetCell === undefined) {
      rowOffsetCell = 0;
    }

    // //表格canvas
    // let renderCtx = null;
    // if (_.isNil(mycanvas)) {
    //   renderCtx = $("#renderCtx")
    //     .get(0)
    //     .getContext("2d");
    // } else {
    //   if (getObjType(mycanvas) === "object") {
    //     try {
    //       renderCtx = mycanvas.get(0).getContext("2d");
    //     } catch (err) {
    //       renderCtx = mycanvas;
    //     }
    //   } else {
    //     renderCtx = $("#" + mycanvas)
    //       .get(0)
    //       .getContext("2d");
    //   }
    // }
    const renderCtx = this.canvasElement.getContext("2d");
    if (!renderCtx) return;

    renderCtx.save();
    renderCtx.scale(
      this.sheetCtx.devicePixelRatio,
      this.sheetCtx.devicePixelRatio
    );
    if (clear) {
      renderCtx.clearRect(
        0,
        0,
        this.sheetCtx.luckysheetTableContentHW[0],
        this.sheetCtx.luckysheetTableContentHW[1]
      );
    }

    // 表格渲染区域, 起止行列index
    let rowStart: number;
    let rowEnd: number;
    let colStart: number;
    let colEnd: number;

    rowStart = _.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight);
    rowEnd = _.sortedIndex(
      this.sheetCtx.visibledatarow,
      scrollHeight + drawHeight
    );

    if (rowStart === -1) {
      rowStart = 0;
    }

    rowStart += rowOffsetCell;

    if (rowEnd === -1) {
      rowEnd = this.sheetCtx.visibledatarow.length - 1;
    }

    rowEnd += rowOffsetCell;

    if (rowEnd >= this.sheetCtx.visibledatarow.length) {
      rowEnd = this.sheetCtx.visibledatarow.length - 1;
    }

    colStart = _.sortedIndex(this.sheetCtx.visibledatacolumn, scrollWidth);
    colEnd = _.sortedIndex(
      this.sheetCtx.visibledatacolumn,
      scrollWidth + drawWidth
    );

    if (colStart === -1) {
      colStart = 0;
    }

    colStart += columnOffsetCell;

    if (colEnd === -1) {
      colEnd = this.sheetCtx.visibledatacolumn.length - 1;
    }

    colEnd += columnOffsetCell;

    if (colEnd >= this.sheetCtx.visibledatacolumn.length) {
      colEnd = this.sheetCtx.visibledatacolumn.length - 1;
    }

    // 表格渲染区域 起止行列坐标
    const rowEndY = this.sheetCtx.visibledatarow[rowEnd];
    const colEndX = this.sheetCtx.visibledatacolumn[colEnd];

    // 表格canvas 初始化处理
    renderCtx.fillStyle = "rgba(255,255,255,0)";
    renderCtx.fillRect(
      offsetLeft - 1,
      offsetTop - 1,
      colEndX - scrollWidth,
      rowEndY - scrollHeight
    );
    renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
    renderCtx.fillStyle = defaultStyle.fillStyle;

    // 表格渲染区域 非空单元格行列 起止坐标
    const cellupdate: {
      r: number;
      c: number;
      startX: number;
      startY: number;
      endY: number;
      endX: number;
      firstcolumnlen: number;
    }[] = [];
    const mergeCache: any = {};
    const borderOffset: any = {};

    const bodrder05 = 0.5; // Default 0.5

    this.sheetCtx.hooks.beforeRenderCellArea?.(flowdata, renderCtx);

    for (let r = rowStart; r <= rowEnd; r += 1) {
      let startY;
      if (r === 0) {
        startY = -scrollHeight - 1;
      } else {
        startY = this.sheetCtx.visibledatarow[r - 1] - scrollHeight - 1;
      }

      const endY = this.sheetCtx.visibledatarow[r] - scrollHeight;

      if (this.sheetCtx.config?.rowhidden?.[r] != null) {
        continue;
      }

      for (let c = colStart; c <= colEnd; c += 1) {
        let startX;
        if (c === 0) {
          startX = -scrollWidth;
        } else {
          startX = this.sheetCtx.visibledatacolumn[c - 1] - scrollWidth;
        }

        const endX = this.sheetCtx.visibledatacolumn[c] - scrollWidth;

        if (this.sheetCtx.config?.colhidden?.[c] != null) {
          continue;
        }

        let firstcolumnlen = this.sheetCtx.defaultcollen;
        if (this.sheetCtx.config?.columnlen?.[c]) {
          firstcolumnlen = this.sheetCtx.config.columnlen[c];
        }

        if (flowdata?.[r]?.[c]) {
          const value = flowdata[r][c];

          if (value?.mc) {
            borderOffset[`${r}_${c}`] = {
              startY,
              startX,
              endY,
              endX,
            };

            if ("rs" in value.mc) {
              const key = `r${r}c${c}`;
              mergeCache[key] = cellupdate.length;
            } else {
              const key = `r${value.mc.r}c${value.mc.c}`;
              const margeMain = cellupdate[mergeCache[key]];

              if (_.isNil(margeMain)) {
                mergeCache[key] = cellupdate.length;
                cellupdate.push({
                  r,
                  c,
                  startX,
                  startY,
                  endY,
                  endX,
                  firstcolumnlen,
                });
              } else {
                if (margeMain.c === c) {
                  margeMain.endY += endY - startY - 1;
                }

                if (margeMain.r === r) {
                  margeMain.endX += endX - startX;
                  margeMain.firstcolumnlen += firstcolumnlen;
                }
              }

              continue;
            }
          }
        }

        cellupdate.push({
          r,
          c,
          startY,
          startX,
          endY,
          endX,
          firstcolumnlen,
        });
        borderOffset[`${r}_${c}`] = {
          startY,
          startX,
          endY,
          endX,
        };
      }
    }

    // 动态数组公式计算
    // const dynamicArrayCompute = dynamicArrayCompute(
    //   this.sheetCtx.luckysheetfile[
    //     getSheetIndex(this.sheetCtx.currentSheetId)
    //   ].dynamicArray
    // );
    const dynamicArrayCompute: any = {};

    // 交替颜色计算
    // const afCompute = alternateformat.getComputeMap();
    const afCompute: any = {};

    // 条件格式计算
    // const cfCompute = conditionformat.getComputeMap();
    const cfCompute: any = getComputeMap(this.sheetCtx);

    // 表格渲染区域 溢出单元格配置保存
    const cellOverflowMap = this.getCellOverflowMap(
      renderCtx,
      colStart,
      colEnd,
      rowStart,
      rowEnd
    );

    const mcArr: typeof cellupdate = [];

    for (let cud = 0; cud < cellupdate.length; cud += 1) {
      const item = cellupdate[cud];
      const { r } = item;
      const { c } = item;
      const { startY } = item;
      const { startX } = item;
      const { endY } = item;
      const { endX } = item;

      if (_.isNil(flowdata[r])) {
        continue;
      }

      if (_.isNil(flowdata[r][c])) {
        // 空单元格
        this.nullCellRender(
          r,
          c,
          startY,
          startX,
          endY,
          endX,
          renderCtx,
          afCompute,
          cfCompute,
          offsetLeft,
          offsetTop,
          dynamicArrayCompute,
          cellOverflowMap,
          colStart,
          colEnd,
          scrollHeight,
          scrollWidth,
          bodrder05
        );
      } else {
        const cell = flowdata[r][c];
        let value = null;

        if (cell?.mc) {
          mcArr.push(cellupdate[cud]);
          // continue;
        } else {
          value = getRealCellValue(r, c, flowdata);
        }

        if (_.isNil(value) || value.toString().length === 0) {
          this.nullCellRender(
            r,
            c,
            startY,
            startX,
            endY,
            endX,
            renderCtx,
            afCompute,
            cfCompute,
            offsetLeft,
            offsetTop,
            dynamicArrayCompute,
            cellOverflowMap,
            colStart,
            colEnd,
            scrollHeight,
            scrollWidth,
            bodrder05
          );

          // sparklines渲染
          // const borderfix = getBorderFix(flowdata, r, c);
          // const cellsize = [
          //   startX + offsetLeft + borderfix[0],
          //   startY + offsetTop + borderfix[1],
          //   endX - startX - 3 + borderfix[2],
          //   endY - startY - 3 - 1 + borderfix[3],
          // ];
          // this.sparklinesRender(
          //   r,
          //   c,
          //   cellsize[0],
          //   cellsize[1],
          //   "renderCtx",
          //   renderCtx
          // );
        } else {
          if (`${r}_${c}` in dynamicArrayCompute) {
            // 动态数组公式
            value = dynamicArrayCompute[`${r}_${c}`].v;
          }

          this.cellRender(
            r,
            c,
            startY,
            startX,
            endY,
            endX,
            value,
            renderCtx,
            afCompute,
            cfCompute,
            offsetLeft,
            offsetTop,
            dynamicArrayCompute,
            cellOverflowMap,
            colStart,
            colEnd,
            scrollHeight,
            scrollWidth,
            bodrder05
          );
        }
      }
    }

    // 合并单元格再处理
    for (let m = 0; m < mcArr.length; m += 1) {
      const item = mcArr[m];
      let { r } = item;
      let { c } = item;
      let { startY } = item;
      let { startX } = item;
      let endY = item.endY - 1;
      let endX = item.endX - 1;

      const cell = flowdata[r][c];
      if (!cell) continue;

      let value = null;

      const mergeMaindata = cell.mc;
      if (!mergeMaindata) continue;

      value = getRealCellValue(mergeMaindata.r, mergeMaindata.c, flowdata);

      r = mergeMaindata.r;
      c = mergeMaindata.c;

      const mainCell = flowdata[r][c];

      if (!mainCell?.mc?.rs || !mainCell.mc?.cs) {
        continue;
      }

      if (c === 0) {
        startX = -scrollWidth;
      } else {
        startX = this.sheetCtx.visibledatacolumn[c - 1] - scrollWidth;
      }

      if (r === 0) {
        startY = -scrollHeight - 1;
      } else {
        startY = this.sheetCtx.visibledatarow[r - 1] - scrollHeight - 1;
      }

      endY =
        this.sheetCtx.visibledatarow[r + mainCell.mc.rs - 1] - scrollHeight;
      endX =
        this.sheetCtx.visibledatacolumn[c + mainCell.mc.cs - 1] - scrollWidth;

      if (_.isNil(value) || value.toString().length === 0) {
        this.nullCellRender(
          r,
          c,
          startY,
          startX,
          endY,
          endX,
          renderCtx,
          afCompute,
          cfCompute,
          offsetLeft,
          offsetTop,
          dynamicArrayCompute,
          cellOverflowMap,
          colStart,
          colEnd,
          scrollHeight,
          scrollWidth,
          bodrder05,
          true
        );

        // sparklines渲染
        // const borderfix = getBorderFix(flowdata, r, c);
        // const cellsize = [
        //   startX + offsetLeft + borderfix[0],
        //   startY + offsetTop + borderfix[1],
        //   endX - startX - 3 + borderfix[2],
        //   endY - startY - 3 - 1 + borderfix[3],
        // ];
        // this.sparklinesRender(
        //   r,
        //   c,
        //   cellsize[0],
        //   cellsize[1],
        //   "renderCtx",
        //   renderCtx
        // );
      } else {
        if (`${r}_${c}` in dynamicArrayCompute) {
          // 动态数组公式
          value = dynamicArrayCompute[`${r}_${c}`].v;
        }
        this.cellRender(
          r,
          c,
          startY,
          startX,
          endY,
          endX,
          value,
          renderCtx,
          afCompute,
          cfCompute,
          offsetLeft,
          offsetTop,
          dynamicArrayCompute,
          cellOverflowMap,
          colStart,
          colEnd,
          scrollHeight,
          scrollWidth,
          bodrder05,
          true
        );
      }
    }

    // 数据透视表边框渲染
    /*
    for (let r = rowStart; r <= rowEnd; r += 1) {
      let startY;
      if (r === 0) {
        startY = -scrollHeight - 1;
      } else {
        startY = this.sheetCtx.visibledatarow[r - 1] - scrollHeight - 1;
      }

      const endY = this.sheetCtx.visibledatarow[r] - scrollHeight;

      for (let c = colStart; c <= colEnd; c += 1) {
        let startX;
        if (c === 0) {
          startX = -scrollWidth;
        } else {
          startX = this.sheetCtx.visibledatacolumn[c - 1] - scrollWidth;
        }

        const endX = this.sheetCtx.visibledatacolumn[c] - scrollWidth;

        // 数据透视表
        if (
          !!this.sheetCtx.luckysheetcurrentisPivotTable &&
          pivotTable.drawPivotTable
        ) {
          if ((c === 0 || c === 5) && r <= 11) {
            renderCtx.beginPath();
            renderCtx.moveTo(
              endX - 2 + bodrder05 + offsetLeft,
              startY + offsetTop
            );
            renderCtx.lineTo(
              endX - 2 + bodrder05 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = "#000000";
            renderCtx.closePath();
            renderCtx.stroke();
          }

          if ((r === 2 || r === 11) && c <= 5) {
            renderCtx.beginPath();
            renderCtx.moveTo(
              startX - 1 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineTo(
              endX - 2 + bodrder05 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = "#000000";
            renderCtx.closePath();
            renderCtx.stroke();
          }

          if (r === 6 && c === 3) {
            renderCtx.save();
            renderCtx.font = "bold 30px Arial";
            renderCtx.fillStyle = "#626675";
            renderCtx.textAlign = "center";
            renderCtx.fillText(
              locale().pivotTable.title,
              startX + (endX - startX) / 2 + 4 + offsetLeft,
              startY + (endY - startY) / 2 - 1 + offsetTop
            );
            renderCtx.restore();
          }
        } else if (this.sheetCtx.luckysheetcurrentisPivotTable) {
          if (
            c < pivotTable.pivotTableBoundary[1] &&
            r < pivotTable.pivotTableBoundary[0]
          ) {
            renderCtx.beginPath();
            renderCtx.moveTo(
              endX - 2 + bodrder05 + offsetLeft,
              startY + offsetTop
            );
            renderCtx.lineTo(
              endX - 2 + bodrder05 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = "#000000";
            renderCtx.closePath();
            renderCtx.stroke();

            renderCtx.beginPath();
            renderCtx.moveTo(
              startX - 1 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineTo(
              endX - 2 + offsetLeft,
              endY - 2 + bodrder05 + offsetTop
            );
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = "#000000";
            renderCtx.closePath();
            renderCtx.stroke();
          }
        }
      }
    }
    */

    // 边框单独渲染
    if ((this.sheetCtx.config?.borderInfo?.length ?? 0) > 0) {
      // 边框渲染
      type BorderRender = (
        style: any,
        color: string,
        startY: number,
        startX: number,
        endY: number,
        endX: number,
        _offsetLeft: number,
        _offsetTop: number,
        canvas: CanvasRenderingContext2D
      ) => void;

      const borderSlashRender: BorderRender = (
        style,
        color,
        startY,
        startX,
        endY,
        endX,
        _offsetLeft,
        _offsetTop,
        canvas
      ) => {
        const linetype = style;

        const moveX = startX - 2 + bodrder05 + _offsetLeft;
        const moveY = startY + _offsetTop;
        const toX = endX - 2 + bodrder05 + _offsetLeft;
        const toY = endY - 2 + bodrder05 + _offsetTop;
        canvas.save();
        setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);

        canvas.strokeStyle = color;

        canvas.stroke();
        canvas.closePath();
        canvas.restore();
      };

      const borderLeftRender: BorderRender = (
        style,
        color,
        startY,
        startX,
        endY,
        endX,
        _offsetLeft,
        _offsetTop,
        canvas
      ) => {
        const linetype = style;

        const moveX = startX - 2 + bodrder05 + _offsetLeft;
        const moveY = startY + _offsetTop - 1;
        const toX = startX - 2 + bodrder05 + _offsetLeft;
        const toY = endY - 2 + bodrder05 + _offsetTop;
        canvas.save();
        setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);

        canvas.strokeStyle = color;

        canvas.stroke();
        canvas.closePath();
        canvas.restore();
      };

      const borderRightRender: BorderRender = (
        style,
        color,
        startY,
        startX,
        endY,
        endX,
        _offsetLeft,
        _offsetTop,
        canvas
      ) => {
        const linetype = style;

        const moveX = endX - 2 + bodrder05 + _offsetLeft;
        const moveY = startY + _offsetTop - 1;
        const toX = endX - 2 + bodrder05 + _offsetLeft;
        const toY = endY - 2 + bodrder05 + _offsetTop;
        canvas.save();
        setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);

        canvas.strokeStyle = color;

        canvas.stroke();
        canvas.closePath();
        canvas.restore();
      };

      const borderBottomRender: BorderRender = (
        style,
        color,
        startY,
        startX,
        endY,
        endX,
        _offsetLeft,
        _offsetTop,
        canvas
      ) => {
        const linetype = style;

        const moveX = startX - 2 + bodrder05 + _offsetLeft;
        const moveY = endY - 2 + bodrder05 + _offsetTop;
        const toX = endX - 2 + bodrder05 + _offsetLeft;
        const toY = endY - 2 + bodrder05 + _offsetTop;
        canvas.save();
        setLineDash(canvas, linetype, "h", moveX, moveY, toX, toY);

        canvas.strokeStyle = color;

        canvas.stroke();
        canvas.closePath();
        canvas.restore();
      };

      const borderTopRender: BorderRender = (
        style,
        color,
        startY,
        startX,
        endY,
        endX,
        _offsetLeft,
        _offsetTop,
        canvas
      ) => {
        const linetype = style;

        const moveX = startX - 2 + bodrder05 + _offsetLeft;
        const moveY = startY - 1 + bodrder05 + _offsetTop;
        const toX = endX - 2 + bodrder05 + _offsetLeft;
        const toY = startY - 1 + bodrder05 + _offsetTop;
        canvas.save();
        setLineDash(canvas, linetype, "h", moveX, moveY, toX, toY);

        canvas.strokeStyle = color;

        canvas.stroke();
        canvas.closePath();
        canvas.restore();
      };

      const borderInfoCompute = getBorderInfoComputeRange(
        this.sheetCtx,
        rowStart,
        rowEnd,
        colStart,
        colEnd
      );

      Object.keys(borderInfoCompute).forEach((x) => {
        const bdRow = Number(x.substring(0, x.indexOf("_")));
        const bdCol = Number(x.substring(x.indexOf("_") + 1));

        if (borderOffset[`${bdRow}_${bdCol}`]) {
          const { startY } = borderOffset[`${bdRow}_${bdCol}`];
          const { startX } = borderOffset[`${bdRow}_${bdCol}`];
          const { endY } = borderOffset[`${bdRow}_${bdCol}`];
          const { endX } = borderOffset[`${bdRow}_${bdCol}`];

          const cellOverflow_colInObj = this.cellOverflow_colIn(
            cellOverflowMap,
            bdRow,
            bdCol,
            colStart,
            colEnd
          );

          const borderSlash = borderInfoCompute[x].s;
          if (
            borderSlash &&
            (!cellOverflow_colInObj.colIn ||
              cellOverflow_colInObj.stc === bdCol)
          ) {
            const mergeMap = this.sheetCtx.config.merge;
            const mergeCell = mergeMap?.[`${bdRow}_${bdCol}`];
            let mergeCellEndX;
            let mergeCellEndY;
            if (mergeCell) {
              const mergeCellOffset =
                borderOffset[
                  `${bdRow + mergeCell.rs - 1}_${bdCol + mergeCell.cs - 1}`
                ];
              mergeCellEndX = mergeCellOffset.endX;
              mergeCellEndY = mergeCellOffset.endY;
            }
            borderSlashRender(
              borderSlash.style,
              borderSlash.color,
              startY,
              startX,
              mergeCellEndY ?? endY,
              mergeCellEndX ?? endX,
              offsetLeft!,
              offsetTop!,
              renderCtx
            );
          }

          const borderLeft = borderInfoCompute[x].l;
          if (
            borderLeft &&
            (!cellOverflow_colInObj.colIn ||
              cellOverflow_colInObj.stc === bdCol)
          ) {
            borderLeftRender(
              borderLeft.style,
              borderLeft.color,
              startY,
              startX,
              endY,
              endX,
              offsetLeft!,
              offsetTop!,
              renderCtx
            );
          }

          const borderRight = borderInfoCompute[x].r;
          if (
            borderRight &&
            (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.colLast)
          ) {
            borderRightRender(
              borderRight.style,
              borderRight.color,
              startY,
              startX,
              endY,
              endX,
              offsetLeft!,
              offsetTop!,
              renderCtx
            );
          }

          const borderTop = borderInfoCompute[x].t;
          if (borderTop) {
            borderTopRender(
              borderTop.style,
              borderTop.color,
              startY,
              startX,
              endY,
              endX,
              offsetLeft!,
              offsetTop!,
              renderCtx
            );
          }

          const borderBottom = borderInfoCompute[x].b;
          if (borderBottom) {
            borderBottomRender(
              borderBottom.style,
              borderBottom.color,
              startY,
              startX,
              endY,
              endX,
              offsetLeft!,
              offsetTop!,
              renderCtx
            );
          }
        }
      });
    }

    // 渲染表格时有尾列时，清除右边灰色区域，防止表格有值溢出
    if (colEnd === this.sheetCtx.visibledatacolumn.length - 1) {
      renderCtx.clearRect(
        colEndX - scrollWidth + offsetLeft - 1,
        offsetTop - 1,
        this.sheetCtx.ch_width - this.sheetCtx.visibledatacolumn[colEnd],
        rowEndY - scrollHeight
      );
    }

    renderCtx.restore();

    this.measureTextCacheTimeOut = setTimeout(() => {
      clearMeasureTextCache();
      this.cellOverflowMapCache = {};
    }, 100);
  }

  // 获取表格渲染范围 溢出单元格
  getCellOverflowMap(
    canvas: CanvasRenderingContext2D,
    colStart: number,
    colEnd: number,
    rowStart: number,
    rowEnd: number
  ) {
    const flowdata = getFlowdata(this.sheetCtx);
    const map: any = {};
    const data = flowdata;
    if (!data) {
      return map;
    }

    for (let r = rowStart; r <= rowEnd; r += 1) {
      if (_.isNil(data[r])) {
        continue;
      }

      if (this.cellOverflowMapCache[r]) {
        map[r] = this.cellOverflowMapCache[r];
        continue;
      }

      let hasCellOver = false;

      for (let c = 0; c < data[r].length; c += 1) {
        const cell = data[r][c];

        if (this.sheetCtx.config?.colhidden?.[c] != null) {
          continue;
        }

        if (
          cell &&
          (!_.isEmpty(cell.v) || isInlineStringCell(cell)) &&
          _.isNil(cell.mc) &&
          cell.tb === "1"
        ) {
          // 水平对齐
          const horizonAlign = normalizedAttr(data, r, c, "ht");

          const textMetricsObj = getCellTextInfo(cell, canvas, this.sheetCtx, {
            r,
            c,
          });
          let textMetrics = 0;
          if (textMetricsObj) {
            textMetrics = textMetricsObj.textWidthAll;
          }

          // canvas.measureText(value).width;

          const startX = c - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[c - 1];
          const endX = this.sheetCtx.visibledatacolumn[c];

          let stc;
          let edc;

          if (endX - startX < textMetrics) {
            if (horizonAlign === "0") {
              // 居中对齐
              const trace_forward = this.cellOverflow_trace(
                r,
                c,
                c - 1,
                "forward",
                horizonAlign,
                textMetrics
              );
              const trace_backward = this.cellOverflow_trace(
                r,
                c,
                c + 1,
                "backward",
                horizonAlign,
                textMetrics
              );

              if (trace_forward.success) {
                stc = trace_forward.c;
              } else {
                stc = trace_forward.c + 1;
              }

              if (trace_backward.success) {
                edc = trace_backward.c;
              } else {
                edc = trace_backward.c - 1;
              }
            } else if (horizonAlign === "1") {
              // 左对齐
              const trace = this.cellOverflow_trace(
                r,
                c,
                c + 1,
                "backward",
                horizonAlign,
                textMetrics
              );
              stc = c;

              if (trace.success) {
                edc = trace.c;
              } else {
                edc = trace.c - 1;
              }
            } else if (horizonAlign === "2") {
              // 右对齐
              const trace = this.cellOverflow_trace(
                r,
                c,
                c - 1,
                "forward",
                horizonAlign,
                textMetrics
              );
              edc = c;

              if (trace.success) {
                stc = trace.c;
              } else {
                stc = trace.c + 1;
              }
            }
          } else {
            stc = c;
            edc = c;
          }

          if ((stc <= colEnd || edc >= colStart) && stc < edc) {
            const item = {
              r,
              stc,
              edc,
            };

            if (_.isNil(map[r])) {
              map[r] = {};
            }

            map[r][c] = item;

            hasCellOver = true;
          }
        }
      }

      if (hasCellOver) {
        this.cellOverflowMapCache[r] = map[r];
      }
    }

    return map;
  }

  // 空白单元格渲染
  nullCellRender(
    r: number,
    c: number,
    startY: number,
    startX: number,
    endY: number,
    endX: number,
    renderCtx: CanvasRenderingContext2D,
    afCompute: any,
    cfCompute: any,
    offsetLeft: number,
    offsetTop: number,
    dynamicArrayCompute: any,
    cellOverflowMap: any,
    colStart: number,
    colEnd: number,
    scrollHeight: number,
    scrollWidth: number,
    bodrder05: any,
    isMerge = false
  ) {
    // const checksAF = alternateformat.checksAF(r, c, afCompute); // 交替颜色
    const checksCF = checkCF(r, c, cfCompute); // 条件格式
    const flowdata = getFlowdata(this.sheetCtx);
    if (!flowdata) return;

    const borderfix = getBorderFix(flowdata, r, c);

    // // 背景色
    let fillStyle = normalizedAttr(flowdata, r, c, "bg");

    // if (checksAF?.[1] {
    //   // 交替颜色
    //   fillStyle = checksAF[1];
    // }

    if (!_.isNil(checksCF) && !_.isNil(checksCF.cellColor)) {
      // 条件格式
      fillStyle = checksCF.cellColor;
    }

    // if (flowdata?.[r]?.[c]?.tc) {
    //   // 标题色
    //   fillStyle = flowdata[r][c].tc;
    // }

    if (!fillStyle) {
      renderCtx.fillStyle = "rgba(255,255,255,0)";
    } else {
      renderCtx.fillStyle = fillStyle;
    }

    // 这里计算canvas需要绘制的矩形范围时,需要留下原本单元格边框的位置
    // 让 fillRect 绘制矩形的起始xy坐标增加1,绘制长宽减少2

    const cellsize = [
      startX + offsetLeft + borderfix[0] + 1,
      startY + offsetTop + borderfix[1] + 1,
      endX - startX + borderfix[2] - (isMerge ? 1 : 0) - 2,
      endY - startY + borderfix[3] - 2,
    ];

    // 单元格渲染前，考虑到合并单元格会再次渲染一遍，统一放到这里
    if (
      this.sheetCtx.hooks.beforeRenderCell?.(
        flowdata[r][c],
        {
          row: r,
          column: c,
          startX: cellsize[0],
          startY: cellsize[1],
          endX: cellsize[2] + cellsize[0],
          endY: cellsize[3] + cellsize[1],
        },
        renderCtx
      ) === false
    ) {
      return;
    }

    renderCtx.fillRect(cellsize[0], cellsize[1], cellsize[2], cellsize[3]);

    if (`${r}_${c}` in dynamicArrayCompute) {
      const value = dynamicArrayCompute[`${r}_${c}`].v;

      renderCtx.fillStyle = "#000000";
      // 文本宽度和高度
      const fontset = defaultFont(this.sheetCtx.defaultFontSize);
      renderCtx.font = fontset;

      // 水平对齐 (默认为1，左对齐)
      const horizonAlignPos = startX + 4 + offsetLeft;

      // 垂直对齐 (默认为2，下对齐)
      const verticalAlignPos = endY + offsetTop - 2;
      renderCtx.textBaseline = "bottom";

      renderCtx.fillText(
        _.isNil(value) ? "" : value,
        horizonAlignPos,
        verticalAlignPos
      );
    }

    // 若单元格有批注
    if (flowdata?.[r]?.[c]?.ps) {
      const ps_w = 8 * this.sheetCtx.zoomRatio;
      const ps_h = 8 * this.sheetCtx.zoomRatio;
      renderCtx.beginPath();
      renderCtx.moveTo(endX + offsetLeft - 1 - ps_w, startY + offsetTop);
      renderCtx.lineTo(endX + offsetLeft - 1, startY + offsetTop);
      renderCtx.lineTo(endX + offsetLeft - 1, startY + offsetTop + ps_h);
      renderCtx.fillStyle = "#FC6666";
      renderCtx.fill();
      renderCtx.closePath();
    }

    // 此单元格 与  溢出单元格关系
    const cellOverflow_colInObj = this.cellOverflow_colIn(
      cellOverflowMap,
      r,
      c,
      colStart,
      colEnd
    );

    // 此单元格 为 溢出单元格渲染范围最后一列，绘制溢出单元格内容
    if (
      cellOverflow_colInObj.colLast &&
      !_.isNil(cellOverflow_colInObj.rowIndex) &&
      !_.isNil(cellOverflow_colInObj.colIndex) &&
      !_.isNil(cellOverflow_colInObj.stc) &&
      !_.isNil(cellOverflow_colInObj.edc)
    ) {
      this.cellOverflowRender(
        cellOverflow_colInObj.rowIndex,
        cellOverflow_colInObj.colIndex,
        cellOverflow_colInObj.stc,
        cellOverflow_colInObj.edc,
        renderCtx,
        scrollHeight,
        scrollWidth,
        offsetLeft,
        offsetTop,
        afCompute,
        cfCompute
      );
    }

    // 即溢出单元格跨此单元格，此单元格不绘制右边框
    if (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.colLast) {
      // 右边框
      // 无论是否有背景色，都默认绘制右边框
      if (
        !this.sheetCtx.luckysheetcurrentisPivotTable &&
        this.sheetCtx.showGridLines
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(endX + offsetLeft - 2 + bodrder05, startY + offsetTop);
        renderCtx.lineTo(endX + offsetLeft - 2 + bodrder05, endY + offsetTop);
        renderCtx.lineWidth = 1;
        renderCtx.strokeStyle = defaultStyle.strokeStyle;
        renderCtx.stroke();
        renderCtx.closePath();
      }
    }

    // 下边框
    // 无论是否有背景色，都默认绘制下边框
    if (
      !this.sheetCtx.luckysheetcurrentisPivotTable &&
      this.sheetCtx.showGridLines
    ) {
      renderCtx.beginPath();
      renderCtx.moveTo(
        startX + offsetLeft - 1,
        endY + offsetTop - 2 + bodrder05
      );
      renderCtx.lineTo(endX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
      renderCtx.lineWidth = 1;

      renderCtx.strokeStyle = defaultStyle.strokeStyle;
      renderCtx.stroke();
      renderCtx.closePath();
    }

    // 单元格渲染后
    this.sheetCtx.hooks.afterRenderCell?.(
      flowdata[r][c],
      {
        row: r,
        column: c,
        startY: cellsize[1],
        startX: cellsize[0],
        endY: cellsize[3] + cellsize[1],
        endX: cellsize[2] + cellsize[0],
      },
      renderCtx
    );
  }

  cellRender(
    r: number,
    c: number,
    startY: number,
    startX: number,
    endY: number,
    endX: number,
    value: any,
    renderCtx: CanvasRenderingContext2D,
    afCompute: any,
    cfCompute: any,
    offsetLeft: number,
    offsetTop: number,
    dynamicArrayCompute: any,
    cellOverflowMap: any,
    colStart: number,
    colEnd: number,
    scrollHeight: number,
    scrollWidth: number,
    bodrder05: number,
    isMerge = false
  ) {
    const flowdata = getFlowdata(this.sheetCtx);
    if (!flowdata) {
      return;
    }
    const cell = flowdata[r][c];
    const cellWidth = endX - startX - 2;
    const cellHeight = endY - startY - 2;
    const space_width = 2;
    const space_height = 2; // 宽高方向 间隙

    // 水平对齐
    const horizonAlign = Number(normalizedAttr(flowdata, r, c, "ht"));
    // 垂直对齐
    const verticalAlign = Number(normalizedAttr(flowdata, r, c, "vt"));

    // 交替颜色
    // const checksAF = alternateformat.checksAF(r, c, afCompute);
    const checksAF: any = {};
    // 条件格式
    const checksCF = checkCF(r, c, cfCompute);

    // 单元格 背景颜色
    let fillStyle = normalizedAttr(flowdata, r, c, "bg");
    // if (checksAF?.[1]) {
    //   // 若单元格有交替颜色 背景颜色
    //   fillStyle = checksAF[1];
    // }
    if (!_.isNil(checksCF) && !_.isNil(checksCF.cellColor)) {
      // 若单元格有条件格式 背景颜色
      fillStyle = checksCF.cellColor;
    }
    if (!fillStyle) {
      renderCtx.fillStyle = "rgba(255,255,255,0)";
    } else {
      renderCtx.fillStyle = fillStyle;
    }

    const borderfix = getBorderFix(flowdata, r, c);

    // 这里计算canvas需要绘制的矩形范围时,需要留下原本单元格边框的位置
    // 让 fillRect 绘制矩形的起始xy坐标增加1,绘制长宽减少2

    const cellsize = [
      startX + offsetLeft + borderfix[0] + 1,
      startY + offsetTop + borderfix[1] + 1,
      endX - startX + borderfix[2] - (isMerge ? 1 : 0) - 2,
      endY - startY + borderfix[3] - 2,
    ];

    // 单元格渲染前，考虑到合并单元格会再次渲染一遍，统一放到这里
    if (
      this.sheetCtx.hooks.beforeRenderCell?.(
        flowdata[r][c],
        {
          row: r,
          column: c,
          startY: cellsize[1],
          startX: cellsize[0],
          endY: cellsize[3] + cellsize[1],
          endX: cellsize[2] + cellsize[0],
        },
        renderCtx
      ) === false
    ) {
      return;
    }

    renderCtx.fillRect(cellsize[0], cellsize[1], cellsize[2], cellsize[3]);

    // const { dataVerification } = dataVerificationCtrl;

    const index = getSheetIndex(
      this.sheetCtx,
      this.sheetCtx.currentSheetId
    ) as number;

    const { dataVerification } = this.sheetCtx.luckysheetfile[index];

    if (
      dataVerification?.[`${r}_${c}`] &&
      !validateCellData(this.sheetCtx, dataVerification[`${r}_${c}`], value)
    ) {
      // 单元格左上角红色小三角标示
      const dv_w = 5 * this.sheetCtx.zoomRatio;
      const dv_h = 5 * this.sheetCtx.zoomRatio; // 红色小三角宽高

      renderCtx.beginPath();
      renderCtx.moveTo(startX + offsetLeft, startY + offsetTop);
      renderCtx.lineTo(startX + offsetLeft + dv_w, startY + offsetTop);
      renderCtx.lineTo(startX + offsetLeft, startY + offsetTop + dv_h);
      renderCtx.fillStyle = "#FC6666";
      renderCtx.fill();
      renderCtx.closePath();
    }

    // 若单元格有批注（单元格右上角红色小三角标示）
    if (cell?.ps) {
      const ps_w = 8 * this.sheetCtx.zoomRatio;
      const ps_h = 8 * this.sheetCtx.zoomRatio; // 红色小三角宽高

      renderCtx.beginPath();
      renderCtx.moveTo(endX + offsetLeft - ps_w, startY + offsetTop);
      renderCtx.lineTo(endX + offsetLeft, startY + offsetTop);
      renderCtx.lineTo(endX + offsetLeft, startY + offsetTop + ps_h);
      renderCtx.fillStyle = "#FC6666";
      renderCtx.fill();
      renderCtx.closePath();
    }

    // 若单元格强制为字符串，则显示绿色小三角
    if (cell?.qp === 1 && isRealNum(cell?.v)) {
      const ps_w = 6 * this.sheetCtx.zoomRatio;
      const ps_h = 6 * this.sheetCtx.zoomRatio; // 红色小三角宽高

      renderCtx.beginPath();
      renderCtx.moveTo(startX + offsetLeft + ps_w - 1, startY + offsetTop);
      renderCtx.lineTo(startX + offsetLeft - 1, startY + offsetTop);
      renderCtx.lineTo(startX + offsetLeft - 1, startY + offsetTop + ps_h);
      renderCtx.fillStyle = "#487f1e";
      renderCtx.fill();
      renderCtx.closePath();
    }

    // 溢出单元格
    let cellOverflow_bd_r_render = true; // 溢出单元格右边框是否需要绘制
    const cellOverflow_colInObj = this.cellOverflow_colIn(
      cellOverflowMap,
      r,
      c,
      colStart,
      colEnd
    );

    if (cell?.tb === "1" && cellOverflow_colInObj.colIn) {
      // 此单元格 为 溢出单元格渲染范围最后一列，绘制溢出单元格内容
      if (
        cellOverflow_colInObj.colLast &&
        !_.isNil(cellOverflow_colInObj.rowIndex) &&
        !_.isNil(cellOverflow_colInObj.colIndex) &&
        !_.isNil(cellOverflow_colInObj.stc) &&
        !_.isNil(cellOverflow_colInObj.edc)
      ) {
        this.cellOverflowRender(
          cellOverflow_colInObj.rowIndex,
          cellOverflow_colInObj.colIndex,
          cellOverflow_colInObj.stc,
          cellOverflow_colInObj.edc,
          renderCtx,
          scrollHeight,
          scrollWidth,
          offsetLeft,
          offsetTop,
          afCompute,
          cfCompute
        );
      } else {
        cellOverflow_bd_r_render = false;
      }
    }
    // 数据验证 复选框
    else if (dataVerification?.[`${r}_${c}`]?.type === "checkbox") {
      const pos_x = startX + offsetLeft;
      const pos_y = startY + offsetTop + 1;

      renderCtx.save();
      renderCtx.beginPath();
      renderCtx.rect(pos_x, pos_y, cellWidth, cellHeight);
      renderCtx.clip();
      renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);

      const measureText = getMeasureText(value, renderCtx, this.sheetCtx);
      const textMetrics = measureText.width + 14;
      const oneLineTextHeight =
        measureText.actualBoundingBoxDescent +
        measureText.actualBoundingBoxAscent;

      let horizonAlignPos = pos_x + space_width; // 默认为1，左对齐
      if (horizonAlign === 0) {
        // 居中对齐
        horizonAlignPos = pos_x + cellWidth / 2 - textMetrics / 2;
      } else if (horizonAlign === 2) {
        // 右对齐
        horizonAlignPos = pos_x + cellWidth - space_width - textMetrics;
      }

      const verticalCellHeight =
        cellHeight > oneLineTextHeight ? cellHeight : oneLineTextHeight;

      let verticalAlignPos_text = pos_y + verticalCellHeight - space_height; // 文本垂直方向基准线
      renderCtx.textBaseline = "bottom";
      let verticalAlignPos_checkbox =
        verticalAlignPos_text - 13 * this.sheetCtx.zoomRatio;

      if (verticalAlign === 0) {
        // 居中对齐
        verticalAlignPos_text = pos_y + verticalCellHeight / 2;
        renderCtx.textBaseline = "middle";
        verticalAlignPos_checkbox =
          verticalAlignPos_text - 6 * this.sheetCtx.zoomRatio;
      } else if (verticalAlign === 1) {
        // 上对齐
        verticalAlignPos_text = pos_y + space_height;
        renderCtx.textBaseline = "top";
        verticalAlignPos_checkbox =
          verticalAlignPos_text + 1 * this.sheetCtx.zoomRatio;
      }

      horizonAlignPos /= this.sheetCtx.zoomRatio;
      verticalAlignPos_text /= this.sheetCtx.zoomRatio;
      verticalAlignPos_checkbox /= this.sheetCtx.zoomRatio;

      // 复选框
      renderCtx.lineWidth = 1;
      renderCtx.strokeStyle = "#000";
      renderCtx.strokeRect(horizonAlignPos, verticalAlignPos_checkbox, 10, 10);

      if (dataVerification[`${r}_${c}`].checked) {
        renderCtx.beginPath();
        renderCtx.lineTo(horizonAlignPos + 1, verticalAlignPos_checkbox + 6);
        renderCtx.lineTo(horizonAlignPos + 4, verticalAlignPos_checkbox + 9);
        renderCtx.lineTo(horizonAlignPos + 9, verticalAlignPos_checkbox + 2);
        renderCtx.stroke();
        renderCtx.closePath();
      }

      // 文本
      renderCtx.fillStyle = normalizedAttr(flowdata, r, c, "fc");
      renderCtx.fillText(
        _.isNil(value) ? "" : value,
        horizonAlignPos + 14,
        verticalAlignPos_text
      );

      renderCtx.restore();
    } else {
      // 若单元格有条件格式数据条
      if (
        checksCF?.dataBar?.valueLen &&
        checksCF?.dataBar?.valueLen?.toString() !== "NaN"
      ) {
        const x = startX + offsetLeft + space_width;
        const y = startY + offsetTop + space_height;
        const w = cellWidth - space_width * 2;
        const h = cellHeight - space_height * 2;

        const { valueType } = checksCF.dataBar;
        const { valueLen } = checksCF.dataBar;
        const { format } = checksCF.dataBar;

        if (valueType === "minus") {
          // 负数
          const { minusLen } = checksCF.dataBar;

          if (format.length > 1) {
            // 渐变
            const my_gradient = renderCtx.createLinearGradient(
              x + w * minusLen * (1 - valueLen),
              y,
              x + w * minusLen,
              y
            );
            my_gradient.addColorStop(0, "#ffffff");
            my_gradient.addColorStop(1, "#ff0000");

            renderCtx.fillStyle = my_gradient;
          } else {
            // 单色
            renderCtx.fillStyle = "#ff0000";
          }

          renderCtx.fillRect(
            x + w * minusLen * (1 - valueLen),
            y,
            w * minusLen * valueLen,
            h
          );

          renderCtx.beginPath();
          renderCtx.moveTo(x + w * minusLen * (1 - valueLen), y);
          renderCtx.lineTo(x + w * minusLen * (1 - valueLen), y + h);
          renderCtx.lineTo(x + w * minusLen, y + h);
          renderCtx.lineTo(x + w * minusLen, y);
          renderCtx.lineTo(x + w * minusLen * (1 - valueLen), y);
          renderCtx.lineWidth = 1;
          renderCtx.strokeStyle = "#ff0000";
          renderCtx.stroke();
          renderCtx.closePath();
        } else if (valueType === "plus") {
          // 正数
          const { plusLen } = checksCF.dataBar;

          if (plusLen === 1) {
            if (format.length > 1) {
              // 渐变
              const my_gradient = renderCtx.createLinearGradient(
                x,
                y,
                x + w * valueLen,
                y
              );
              my_gradient.addColorStop(0, format[0]);
              my_gradient.addColorStop(1, format[1]);

              renderCtx.fillStyle = my_gradient;
            } else {
              // 单色
              [renderCtx.fillStyle] = format;
            }

            renderCtx.fillRect(x, y, w * valueLen, h);

            renderCtx.beginPath();
            renderCtx.moveTo(x, y);
            renderCtx.lineTo(x, y + h);
            renderCtx.lineTo(x + w * valueLen, y + h);
            renderCtx.lineTo(x + w * valueLen, y);
            renderCtx.lineTo(x, y);
            renderCtx.lineWidth = 1;
            [renderCtx.strokeStyle] = format;
            renderCtx.stroke();
            renderCtx.closePath();
          } else {
            const { minusLen } = checksCF.dataBar;

            if (format.length > 1) {
              // 渐变
              const my_gradient = renderCtx.createLinearGradient(
                x + w * minusLen,
                y,
                x + w * minusLen + w * plusLen * valueLen,
                y
              );
              my_gradient.addColorStop(0, format[0]);
              my_gradient.addColorStop(1, format[1]);

              renderCtx.fillStyle = my_gradient;
            } else {
              // 单色
              [renderCtx.fillStyle] = format;
            }

            renderCtx.fillRect(x + w * minusLen, y, w * plusLen * valueLen, h);

            renderCtx.beginPath();
            renderCtx.moveTo(x + w * minusLen, y);
            renderCtx.lineTo(x + w * minusLen, y + h);
            renderCtx.lineTo(x + w * minusLen + w * plusLen * valueLen, y + h);
            renderCtx.lineTo(x + w * minusLen + w * plusLen * valueLen, y);
            renderCtx.lineTo(x + w * minusLen, y);
            renderCtx.lineWidth = 1;
            [renderCtx.strokeStyle] = format;
            renderCtx.stroke();
            renderCtx.closePath();
          }
        }
      }

      const pos_x = startX + offsetLeft;
      const pos_y = startY + offsetTop + 1;

      renderCtx.save();
      renderCtx.beginPath();
      renderCtx.rect(pos_x, pos_y, cellWidth, cellHeight);
      renderCtx.clip();
      renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);

      const textInfo = cell
        ? getCellTextInfo(
            cell,
            renderCtx,
            this.sheetCtx,
            {
              cellWidth,
              cellHeight,
              space_width,
              space_height,
              r,
              c,
            },
            this.sheetCtx
          )
        : undefined;

      // 若单元格有条件格式图标集
      if (checksCF?.icons && textInfo.type === "plain") {
        const l = checksCF.icons.left;
        const t = checksCF.icons.top;

        const _value = textInfo.values[0];
        let verticalAlignPos = pos_y + _value.top - textInfo.textHeightAll;

        if (verticalAlign === 0) {
          // 居中对齐
          verticalAlignPos =
            pos_y + cellHeight / 2 - textInfo.textHeightAll / 2;
        } else if (verticalAlign === 1) {
          // 上对齐
          verticalAlignPos = pos_y;
        } else if (verticalAlign === 2) {
          // 下对齐
          verticalAlignPos -= textInfo.desc;
        }

        verticalAlignPos /= this.sheetCtx.zoomRatio;

        renderCtx.drawImage(
          getCfIconsImg(),
          l * 42,
          t * 32,
          32,
          32,
          pos_x / this.sheetCtx.zoomRatio,
          verticalAlignPos,
          textInfo.textHeightAll / this.sheetCtx.zoomRatio,
          textInfo.textHeightAll / this.sheetCtx.zoomRatio
        );
      }

      // 单元格 文本颜色
      renderCtx.fillStyle = normalizedAttr(flowdata, r, c, "fc");

      // 若单元格有交替颜色 文本颜色
      if (checksAF?.[0]) {
        [renderCtx.fillStyle] = checksAF;
      }
      // 若单元格有条件格式 文本颜色
      if (checksCF?.textColor) {
        renderCtx.fillStyle = checksCF.textColor;
      }

      // 若单元格格式为自定义数字格式（[red]） 文本颜色为红色
      if (
        (cell?.ct?.fa?.indexOf("[Red]") ?? -1) > -1 &&
        cell?.ct?.t === "n" &&
        (cell?.v as number) < 0
      ) {
        renderCtx.fillStyle = "#ff0000";
      }

      this.cellTextRender(textInfo, renderCtx, {
        pos_x,
        pos_y,
      });

      renderCtx.restore();
    }

    if (cellOverflow_bd_r_render) {
      // 右边框
      if (
        !this.sheetCtx.luckysheetcurrentisPivotTable &&
        this.sheetCtx.showGridLines
      ) {
        renderCtx.beginPath();
        renderCtx.moveTo(endX + offsetLeft - 2 + bodrder05, startY + offsetTop);
        renderCtx.lineTo(endX + offsetLeft - 2 + bodrder05, endY + offsetTop);
        renderCtx.lineWidth = 1;
        renderCtx.strokeStyle = defaultStyle.strokeStyle;
        renderCtx.stroke();
        renderCtx.closePath();
      }
    }

    // 下边框
    if (
      !this.sheetCtx.luckysheetcurrentisPivotTable &&
      this.sheetCtx.showGridLines
    ) {
      renderCtx.beginPath();
      renderCtx.moveTo(
        startX + offsetLeft - 1,
        endY + offsetTop - 2 + bodrder05
      );
      renderCtx.lineTo(endX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
      renderCtx.lineWidth = 1;
      renderCtx.strokeStyle = defaultStyle.strokeStyle;
      renderCtx.stroke();
      renderCtx.closePath();
    }

    // 单元格渲染后
    this.sheetCtx.hooks.afterRenderCell?.(
      flowdata[r]?.[c],
      {
        row: r,
        column: c,
        startX: cellsize[0],
        startY: cellsize[1],
        endX: cellsize[2] + cellsize[0],
        endY: cellsize[3] + cellsize[1],
      },
      renderCtx
    );
  }

  // 溢出单元格渲染
  cellOverflowRender(
    r: number,
    c: number,
    stc: number,
    edc: number,
    renderCtx: CanvasRenderingContext2D,
    scrollHeight: number,
    scrollWidth: number,
    offsetLeft: number,
    offsetTop: number,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    afCompute: any,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    cfCompute: any
  ) {
    // 溢出单元格 起止行列坐标
    let startY;
    if (r === 0) {
      startY = -scrollHeight - 1;
    } else {
      startY = this.sheetCtx.visibledatarow[r - 1] - scrollHeight - 1;
    }

    const endY = this.sheetCtx.visibledatarow[r] - scrollHeight;

    let startX;
    if (stc === 0) {
      startX = -scrollWidth;
    } else {
      startX = this.sheetCtx.visibledatacolumn[stc - 1] - scrollWidth;
    }

    const endX = this.sheetCtx.visibledatacolumn[edc] - scrollWidth;

    //
    const flowdata = getFlowdata(this.sheetCtx);
    if (!flowdata) {
      return;
    }
    const cell = flowdata[r][c];
    const cellWidth = endX - startX - 2;
    const cellHeight = endY - startY - 2;
    const space_width = 2;
    const space_height = 2; // 宽高方向 间隙

    const pos_x = startX + offsetLeft;
    const pos_y = startY + offsetTop + 1;

    const fontset = getFontSet(
      cell,
      this.sheetCtx.defaultFontSize,
      this.sheetCtx
    );
    renderCtx.font = fontset;

    renderCtx.save();
    renderCtx.beginPath();
    renderCtx.rect(pos_x, pos_y, cellWidth, cellHeight);
    renderCtx.clip();
    renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);

    const textInfo = cell
      ? getCellTextInfo(
          cell,
          renderCtx,
          this.sheetCtx,
          {
            cellWidth,
            cellHeight,
            space_width,
            space_height,
            r,
            c,
          },
          this.sheetCtx
        )
      : undefined;

    // 交替颜色
    // const checksAF = alternateformat.checksAF(r, c, afCompute);
    const checksAF: any = {};
    // 条件格式
    // const checksCF = conditionformat.checksCF(r, c, cfCompute);
    const checksCF: any = checkCF(r, c, cfCompute);

    // 单元格 文本颜色
    renderCtx.fillStyle = normalizedAttr(flowdata, r, c, "fc");

    // 若单元格有交替颜色 文本颜色
    if (checksAF?.[0]) {
      [renderCtx.fillStyle] = checksAF;
    }
    // 若单元格有条件格式 文本颜色
    if (checksCF?.textColor) {
      renderCtx.fillStyle = checksCF.textColor;
    }

    this.cellTextRender(textInfo, renderCtx, {
      pos_x,
      pos_y,
    });

    renderCtx.restore();
  }

  cellOverflow_trace(
    r: number,
    curC: number,
    traceC: number,
    traceDir: string,
    horizonAlign: string,
    textMetrics: number
  ): any {
    const flowdata = getFlowdata(this.sheetCtx);
    if (!flowdata) return {};
    const data = flowdata;

    // 追溯单元格列超出数组范围 则追溯终止
    if (traceDir === "forward" && traceC < 0) {
      return {
        success: false,
        r,
        c: traceC,
      };
    }

    if (traceDir === "backward" && traceC > data[r].length - 1) {
      return {
        success: false,
        r,
        c: traceC,
      };
    }

    // 追溯单元格是 非空单元格或合并单元格 则追溯终止
    const cell = data[r][traceC];
    if (cell && (!_.isEmpty(cell.v) || cell.mc)) {
      return {
        success: false,
        r,
        c: traceC,
      };
    }

    let start_curC =
      curC - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[curC - 1];
    let end_curC = this.sheetCtx.visibledatacolumn[curC];

    const w = textMetrics - (end_curC - start_curC);

    if (horizonAlign === "0") {
      // 居中对齐
      start_curC -= w / 2;
      end_curC += w / 2;
    } else if (horizonAlign === "1") {
      // 左对齐
      end_curC += w;
    } else if (horizonAlign === "2") {
      // 右对齐
      start_curC -= w;
    }

    const start_traceC =
      traceC - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[traceC - 1];
    const end_traceC = this.sheetCtx.visibledatacolumn[traceC];

    if (traceDir === "forward") {
      if (start_curC < start_traceC) {
        return this.cellOverflow_trace(
          r,
          curC,
          traceC - 1,
          traceDir,
          horizonAlign,
          textMetrics
        );
      }
      if (start_curC < end_traceC) {
        return {
          success: true,
          r,
          c: traceC,
        };
      }
      return {
        success: false,
        r,
        c: traceC,
      };
    }

    if (traceDir === "backward") {
      if (end_curC > end_traceC) {
        return this.cellOverflow_trace(
          r,
          curC,
          traceC + 1,
          traceDir,
          horizonAlign,
          textMetrics
        );
      }
      if (end_curC > start_traceC) {
        return {
          success: true,
          r,
          c: traceC,
        };
      }
      return {
        success: false,
        r,
        c: traceC,
      };
    }
    return null;
  }

  cellOverflow_colIn(
    map: any,
    r: number,
    c: number,
    col_st: number,
    col_ed: number
  ) {
    let colIn = false; // 此单元格 是否在 某个溢出单元格的渲染范围
    let colLast = false; // 此单元格 是否是 某个溢出单元格的渲染范围的最后一列
    let rowIndex: number | undefined; // 溢出单元格 行下标
    let colIndex: number | undefined; // 溢出单元格 列下标
    let stc: number | undefined;
    let edc: number | undefined;

    _.forEach(map, (row, rkey) => {
      _.forEach(row, (mapItem, ckey) => {
        rowIndex = Number(rkey);
        colIndex = Number(ckey);
        stc = mapItem.stc;
        edc = mapItem.edc;

        if (rowIndex === r) {
          if (c >= (stc as number) && c <= (edc as number)) {
            colIn = true;

            if (c === edc || c === col_ed) {
              colLast = true;
              return false;
            }
          }
        }
        return true;
      });
      return !colLast;
    });

    return {
      colIn,
      colLast,
      rowIndex,
      colIndex,
      stc,
      edc,
    };
  }

  cellTextRender(textInfo: any, ctx: CanvasRenderingContext2D, option: any) {
    if (!textInfo) {
      return;
    }
    const { values } = textInfo;
    const { pos_x } = option;
    const { pos_y } = option;
    if (!values) {
      return;
    }
    // console.log(textInfo, pos_x, pos_y, values[0].width, values[0].left, ctx);

    // for(let i=0;i<values.length;i++){
    //     let word = values[i];
    //     ctx.font = word.style;
    //     ctx.fillText(word.content, (pos_x + word.left)/this.sheetCtx.zoomRatio, (pos_y+word.top)/this.sheetCtx.zoomRatio);
    // }

    // ctx.fillStyle = "rgba(255,255,0,0.2)";
    // ctx.fillRect((pos_x + values[0].left)/this.sheetCtx.zoomRatio, (pos_y+values[0].top-values[0].asc)/this.sheetCtx.zoomRatio, textInfo.textWidthAll, textInfo.textHeightAll)

    if (textInfo.rotate !== 0 && textInfo.type !== "verticalWrap") {
      ctx.save();
      ctx.translate(
        (pos_x + textInfo.textLeftAll) / this.sheetCtx.zoomRatio,
        (pos_y + textInfo.textTopAll) / this.sheetCtx.zoomRatio
      );
      ctx.rotate((-textInfo.rotate * Math.PI) / 180);
      ctx.translate(
        -(textInfo.textLeftAll + pos_x) / this.sheetCtx.zoomRatio,
        -(pos_y + textInfo.textTopAll) / this.sheetCtx.zoomRatio
      );
    }

    for (let i = 0; i < values.length; i += 1) {
      const word = values[i];
      if (word.inline === true && word.style) {
        ctx.font = word.style.fontset;
        ctx.fillStyle = word.style.fc;
      } else {
        ctx.font = word.style;
      }

      // 暂时未排查到word.content第一次会是object，先做下判断来渲染，后续找到问题再复原
      const txt = _.isPlainObject(word.content) ? word.content.m : word.content;
      ctx.fillText(
        txt,
        (pos_x + word.left) / this.sheetCtx.zoomRatio,
        (pos_y + word.top) / this.sheetCtx.zoomRatio
      );

      if (word.cancelLine) {
        const c = word.cancelLine;
        ctx.beginPath();
        ctx.moveTo(
          Math.floor((pos_x + c.startX) / this.sheetCtx.zoomRatio) + 0.5,
          Math.floor((pos_y + c.startY) / this.sheetCtx.zoomRatio) + 0.5
        );
        ctx.lineTo(
          Math.floor((pos_x + c.endX) / this.sheetCtx.zoomRatio) + 0.5,
          Math.floor((pos_y + c.endY) / this.sheetCtx.zoomRatio) + 0.5
        );
        ctx.lineWidth = Math.floor(c.fs / 9);
        ctx.strokeStyle = ctx.fillStyle;
        ctx.stroke();
        ctx.closePath();
      }

      if (word.underLine) {
        const underLines = word.underLine;
        for (let a = 0; a < underLines.length; a += 1) {
          const item = underLines[a];
          ctx.beginPath();
          ctx.moveTo(
            Math.floor((pos_x + item.startX) / this.sheetCtx.zoomRatio) + 0.5,
            Math.floor((pos_y + item.startY) / this.sheetCtx.zoomRatio)
          );
          ctx.lineTo(
            Math.floor((pos_x + item.endX) / this.sheetCtx.zoomRatio) + 0.5,
            Math.floor((pos_y + item.endY) / this.sheetCtx.zoomRatio) + 0.5
          );
          ctx.lineWidth = Math.floor(item.fs / 9);
          ctx.strokeStyle = ctx.fillStyle;
          ctx.stroke();
          ctx.closePath();
        }
      }
    }
    if (textInfo.rotate !== 0 && textInfo.type !== "verticalWrap") {
      ctx.restore();
    }
  }

  drawFreezeLine({
    horizontalTop,
    verticalLeft,
  }: {
    horizontalTop?: number;
    verticalLeft?: number;
  }) {
    const renderCtx = this.canvasElement.getContext("2d");
    if (!renderCtx) return;

    renderCtx.save();
    renderCtx.scale(
      this.sheetCtx.devicePixelRatio,
      this.sheetCtx.devicePixelRatio
    );
    renderCtx.strokeStyle = "#ccc";
    renderCtx.lineWidth = 2;

    if (horizontalTop) {
      renderCtx.beginPath();
      renderCtx.moveTo(0, horizontalTop);
      renderCtx.lineTo(this.canvasElement.width, horizontalTop);
      renderCtx.stroke();
      renderCtx.closePath();
    }

    if (verticalLeft) {
      renderCtx.beginPath();
      renderCtx.moveTo(verticalLeft, 0);
      renderCtx.lineTo(verticalLeft, this.canvasElement.height);
      renderCtx.stroke();
      renderCtx.closePath();
    }

    renderCtx.restore();
  }
}
